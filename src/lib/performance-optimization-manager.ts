/**
 * 性能优化管理器
 * 提供内存管理、渲染优化、错误处理等功能
 */

/**
 * 性能指标类型
 */
interface PerformanceMetrics {
  memoryUsage: number;
  renderTime: number;
  componentCount: number;
  spriteCount: number;
  actionCount: number;
  fps: number;
  lastUpdateTime: number;
}

/**
 * 内存监控配置
 */
interface MemoryMonitorConfig {
  maxMemoryUsage: number; // MB
  checkInterval: number; // ms
  warningThreshold: number; // MB
  cleanupThreshold: number; // MB
}

/**
 * 渲染优化配置
 */
interface RenderOptimizationConfig {
  enableVirtualScrolling: boolean;
  maxVisibleItems: number;
  debounceDelay: number;
  enableLazyLoading: boolean;
  cacheSize: number;
}

/**
 * 错误处理配置
 */
interface ErrorHandlingConfig {
  enableErrorBoundary: boolean;
  enableRetry: boolean;
  maxRetryAttempts: number;
  retryDelay: number;
  enableLogging: boolean;
}

/**
 * 性能优化管理器类
 */
export class PerformanceOptimizationManager {
  private metrics: PerformanceMetrics = {
    memoryUsage: 0,
    renderTime: 0,
    componentCount: 0,
    spriteCount: 0,
    actionCount: 0,
    fps: 0,
    lastUpdateTime: 0
  };\n\n  private memoryConfig: MemoryMonitorConfig = {\n    maxMemoryUsage: 512, // 512MB\n    checkInterval: 5000, // 5秒\n    warningThreshold: 256, // 256MB\n    cleanupThreshold: 384 // 384MB\n  };\n\n  private renderConfig: RenderOptimizationConfig = {\n    enableVirtualScrolling: true,\n    maxVisibleItems: 100,\n    debounceDelay: 16,\n    enableLazyLoading: true,\n    cacheSize: 50\n  };\n\n  private errorConfig: ErrorHandlingConfig = {\n    enableErrorBoundary: true,\n    enableRetry: true,\n    maxRetryAttempts: 3,\n    retryDelay: 1000,\n    enableLogging: true\n  };\n\n  private isMonitoring = false;\n  private monitoringInterval: number | null = null;\n  private renderCache = new Map<string, any>();\n  private errorLog: Array<{ timestamp: number; error: Error; context?: string }> = [];\n  \n  // 事件监听器\n  private memoryWarningListeners: ((usage: number) => void)[] = [];\n  private performanceIssueListeners: ((metrics: PerformanceMetrics) => void)[] = [];\n  private errorListeners: ((error: Error, context?: string) => void)[] = [];\n\n  /**\n   * 初始化性能优化管理器\n   */\n  initialize(): void {\n    this.startMonitoring();\n    this.setupErrorHandlers();\n    this.initializeRenderOptimizations();\n    \n    console.log('性能优化管理器初始化完成');\n  }\n\n  /**\n   * 开始性能监控\n   */\n  private startMonitoring(): void {\n    if (this.isMonitoring) return;\n\n    this.isMonitoring = true;\n    this.monitoringInterval = window.setInterval(() => {\n      this.updateMetrics();\n      this.checkMemoryUsage();\n      this.checkPerformanceIssues();\n    }, this.memoryConfig.checkInterval);\n\n    console.log('性能监控已启动');\n  }\n\n  /**\n   * 停止性能监控\n   */\n  private stopMonitoring(): void {\n    if (!this.isMonitoring) return;\n\n    this.isMonitoring = false;\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n    }\n\n    console.log('性能监控已停止');\n  }\n\n  /**\n   * 更新性能指标\n   */\n  private updateMetrics(): void {\n    try {\n      // 内存使用情况\n      if ('memory' in performance) {\n        const memory = (performance as any).memory;\n        this.metrics.memoryUsage = memory.usedJSHeapSize / 1024 / 1024; // MB\n      }\n\n      // FPS 计算\n      const now = performance.now();\n      if (this.metrics.lastUpdateTime > 0) {\n        const deltaTime = now - this.metrics.lastUpdateTime;\n        this.metrics.fps = 1000 / deltaTime;\n      }\n      this.metrics.lastUpdateTime = now;\n\n      // 组件计数\n      this.metrics.componentCount = document.querySelectorAll('[data-component]').length;\n\n    } catch (error) {\n      this.handleError(error as Error, 'updateMetrics');\n    }\n  }\n\n  /**\n   * 检查内存使用情况\n   */\n  private checkMemoryUsage(): void {\n    const { memoryUsage } = this.metrics;\n    const { warningThreshold, cleanupThreshold } = this.memoryConfig;\n\n    if (memoryUsage > cleanupThreshold) {\n      this.performMemoryCleanup();\n    } else if (memoryUsage > warningThreshold) {\n      this.notifyMemoryWarning(memoryUsage);\n    }\n  }\n\n  /**\n   * 检查性能问题\n   */\n  private checkPerformanceIssues(): void {\n    const { fps, renderTime } = this.metrics;\n\n    // FPS 过低\n    if (fps < 30 && fps > 0) {\n      this.notifyPerformanceIssue('FPS过低');\n    }\n\n    // 渲染时间过长\n    if (renderTime > 16) { // 超过一帧的时间\n      this.notifyPerformanceIssue('渲染时间过长');\n    }\n  }\n\n  /**\n   * 执行内存清理\n   */\n  private performMemoryCleanup(): void {\n    try {\n      // 清理渲染缓存\n      this.clearRenderCache();\n\n      // 清理错误日志\n      this.clearOldErrorLogs();\n\n      // 强制垃圾回收（如果可用）\n      if (window.gc) {\n        window.gc();\n      }\n\n      console.log('内存清理完成');\n    } catch (error) {\n      this.handleError(error as Error, 'performMemoryCleanup');\n    }\n  }\n\n  /**\n   * 清理渲染缓存\n   */\n  private clearRenderCache(): void {\n    const cacheSize = this.renderCache.size;\n    if (cacheSize > this.renderConfig.cacheSize) {\n      const deleteCount = cacheSize - this.renderConfig.cacheSize;\n      const keysToDelete = Array.from(this.renderCache.keys()).slice(0, deleteCount);\n      \n      keysToDelete.forEach(key => {\n        this.renderCache.delete(key);\n      });\n\n      console.log(`清理了 ${deleteCount} 个渲染缓存项`);\n    }\n  }\n\n  /**\n   * 清理旧的错误日志\n   */\n  private clearOldErrorLogs(): void {\n    const now = Date.now();\n    const oneHourAgo = now - 60 * 60 * 1000; // 1小时前\n    \n    this.errorLog = this.errorLog.filter(log => log.timestamp > oneHourAgo);\n  }\n\n  /**\n   * 设置错误处理器\n   */\n  private setupErrorHandlers(): void {\n    if (!this.errorConfig.enableErrorBoundary) return;\n\n    // 全局错误处理\n    window.addEventListener('error', (event) => {\n      this.handleError(event.error, 'globalError');\n    });\n\n    // Promise 拒绝处理\n    window.addEventListener('unhandledrejection', (event) => {\n      this.handleError(new Error(event.reason), 'unhandledPromise');\n    });\n  }\n\n  /**\n   * 初始化渲染优化\n   */\n  private initializeRenderOptimizations(): void {\n    // 防抖函数创建\n    this.createDebouncedFunctions();\n    \n    // 虚拟滚动设置\n    this.setupVirtualScrolling();\n    \n    console.log('渲染优化设置完成');\n  }\n\n  /**\n   * 创建防抖函数\n   */\n  private createDebouncedFunctions(): void {\n    // 这里可以创建常用的防抖函数\n  }\n\n  /**\n   * 设置虚拟滚动\n   */\n  private setupVirtualScrolling(): void {\n    if (!this.renderConfig.enableVirtualScrolling) return;\n    \n    // 虚拟滚动逻辑\n    console.log('虚拟滚动已启用');\n  }\n\n  /**\n   * 处理错误\n   */\n  private handleError(error: Error, context?: string): void {\n    // 记录错误\n    this.errorLog.push({\n      timestamp: Date.now(),\n      error,\n      context\n    });\n\n    // 通知监听器\n    this.errorListeners.forEach(listener => {\n      try {\n        listener(error, context);\n      } catch (listenerError) {\n        console.error('错误监听器执行失败:', listenerError);\n      }\n    });\n\n    // 日志记录\n    if (this.errorConfig.enableLogging) {\n      console.error(`[${context || 'unknown'}]`, error);\n    }\n  }\n\n  /**\n   * 通知内存警告\n   */\n  private notifyMemoryWarning(usage: number): void {\n    this.memoryWarningListeners.forEach(listener => {\n      try {\n        listener(usage);\n      } catch (error) {\n        console.error('内存警告监听器执行失败:', error);\n      }\n    });\n  }\n\n  /**\n   * 通知性能问题\n   */\n  private notifyPerformanceIssue(issue: string): void {\n    this.performanceIssueListeners.forEach(listener => {\n      try {\n        listener({ ...this.metrics });\n      } catch (error) {\n        console.error('性能问题监听器执行失败:', error);\n      }\n    });\n\n    console.warn('性能问题:', issue, this.metrics);\n  }\n\n  /**\n   * 重试机制\n   */\n  async retry<T>(\n    operation: () => Promise<T>,\n    context?: string,\n    maxAttempts?: number\n  ): Promise<T> {\n    const attempts = maxAttempts || this.errorConfig.maxRetryAttempts;\n    \n    for (let i = 0; i < attempts; i++) {\n      try {\n        return await operation();\n      } catch (error) {\n        console.warn(`重试 ${i + 1}/${attempts} 失败:`, error);\n        \n        if (i === attempts - 1) {\n          this.handleError(error as Error, context);\n          throw error;\n        }\n        \n        // 等待后重试\n        await new Promise(resolve => setTimeout(resolve, this.errorConfig.retryDelay));\n      }\n    }\n    \n    throw new Error('重试失败');\n  }\n\n  /**\n   * 防抖函数\n   */\n  debounce<T extends (...args: any[]) => any>(\n    func: T,\n    delay?: number\n  ): (...args: Parameters<T>) => void {\n    const wait = delay || this.renderConfig.debounceDelay;\n    let timeoutId: number;\n    \n    return (...args: Parameters<T>) => {\n      clearTimeout(timeoutId);\n      timeoutId = window.setTimeout(() => func(...args), wait);\n    };\n  }\n\n  /**\n   * 节流函数\n   */\n  throttle<T extends (...args: any[]) => any>(\n    func: T,\n    delay?: number\n  ): (...args: Parameters<T>) => void {\n    const wait = delay || this.renderConfig.debounceDelay;\n    let lastCallTime = 0;\n    \n    return (...args: Parameters<T>) => {\n      const now = Date.now();\n      if (now - lastCallTime >= wait) {\n        lastCallTime = now;\n        func(...args);\n      }\n    };\n  }\n\n  /**\n   * 缓存管理\n   */\n  cacheResult<T>(key: string, generator: () => T): T {\n    if (this.renderCache.has(key)) {\n      return this.renderCache.get(key);\n    }\n    \n    const result = generator();\n    this.renderCache.set(key, result);\n    \n    return result;\n  }\n\n  /**\n   * 事件监听器管理\n   */\n  onMemoryWarning(callback: (usage: number) => void): () => void {\n    this.memoryWarningListeners.push(callback);\n    return () => {\n      const index = this.memoryWarningListeners.indexOf(callback);\n      if (index > -1) {\n        this.memoryWarningListeners.splice(index, 1);\n      }\n    };\n  }\n\n  onPerformanceIssue(callback: (metrics: PerformanceMetrics) => void): () => void {\n    this.performanceIssueListeners.push(callback);\n    return () => {\n      const index = this.performanceIssueListeners.indexOf(callback);\n      if (index > -1) {\n        this.performanceIssueListeners.splice(index, 1);\n      }\n    };\n  }\n\n  onError(callback: (error: Error, context?: string) => void): () => void {\n    this.errorListeners.push(callback);\n    return () => {\n      const index = this.errorListeners.indexOf(callback);\n      if (index > -1) {\n        this.errorListeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * 获取性能指标\n   */\n  getMetrics(): PerformanceMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * 更新配置\n   */\n  updateMemoryConfig(config: Partial<MemoryMonitorConfig>): void {\n    this.memoryConfig = { ...this.memoryConfig, ...config };\n  }\n\n  updateRenderConfig(config: Partial<RenderOptimizationConfig>): void {\n    this.renderConfig = { ...this.renderConfig, ...config };\n  }\n\n  updateErrorConfig(config: Partial<ErrorHandlingConfig>): void {\n    this.errorConfig = { ...this.errorConfig, ...config };\n  }\n\n  /**\n   * 获取错误日志\n   */\n  getErrorLog(): typeof this.errorLog {\n    return [...this.errorLog];\n  }\n\n  /**\n   * 获取性能报告\n   */\n  getPerformanceReport(): {\n    metrics: PerformanceMetrics;\n    memoryStatus: string;\n    renderStatus: string;\n    errorCount: number;\n    recommendations: string[];\n  } {\n    const { memoryUsage, fps, renderTime } = this.metrics;\n    const recommendations: string[] = [];\n\n    // 内存状态\n    let memoryStatus = '正常';\n    if (memoryUsage > this.memoryConfig.cleanupThreshold) {\n      memoryStatus = '严重';\n      recommendations.push('建议清理内存或减少组件数量');\n    } else if (memoryUsage > this.memoryConfig.warningThreshold) {\n      memoryStatus = '警告';\n      recommendations.push('监控内存使用情况');\n    }\n\n    // 渲染状态\n    let renderStatus = '正常';\n    if (fps < 30 && fps > 0) {\n      renderStatus = '较差';\n      recommendations.push('优化渲染性能，减少复杂操作');\n    }\n    if (renderTime > 16) {\n      renderStatus = '缓慢';\n      recommendations.push('优化组件渲染逻辑');\n    }\n\n    return {\n      metrics: this.getMetrics(),\n      memoryStatus,\n      renderStatus,\n      errorCount: this.errorLog.length,\n      recommendations\n    };\n  }\n\n  /**\n   * 销毁管理器\n   */\n  destroy(): void {\n    this.stopMonitoring();\n    this.renderCache.clear();\n    this.errorLog = [];\n    this.memoryWarningListeners = [];\n    this.performanceIssueListeners = [];\n    this.errorListeners = [];\n    \n    console.log('性能优化管理器已销毁');\n  }\n}\n\n/**\n * 创建性能优化管理器实例\n */\nexport function createPerformanceOptimizationManager(): PerformanceOptimizationManager {\n  return new PerformanceOptimizationManager();\n}\n\n/**\n * 全局性能优化管理器实例\n */\nexport const performanceOptimizationManager = new PerformanceOptimizationManager();\n\n/**\n * 导出类型\n */\nexport type {\n  PerformanceMetrics,\n  MemoryMonitorConfig,\n  RenderOptimizationConfig,\n  ErrorHandlingConfig\n};